import { writeFile } from 'node:fs/promises'
import { Readable } from 'node:stream'
import {
  addServerHandler,
  addTemplate,
  createResolver,
  defineNuxtModule,
  useLogger,
} from '@nuxt/kit'
import { defu } from 'defu'
import type { SitemapStreamOptions } from 'sitemap'
import { SitemapStream, streamToPromise } from 'sitemap'
import { createRouter as createRadixRouter, toRouteMatcher } from 'radix3'
import chalk from 'chalk'
import { withoutBase, withoutTrailingSlash } from 'ufo'
import type { SitemapItemLoose } from 'sitemap/dist/lib/types'
import type { CreateFilterOptions } from './urlFilter'
import { exposeModuleConfig } from './nuxt-utils'
import { generateRoutes } from './runtime/util/generateRoutes'
import { buildSitemapIndex } from './runtime/util/builder'
// import {generateRoutes} from "./runtime/util/generateRoutes";

export type MaybeFunction<T> = T | (() => T)
export type MaybePromise<T> = T | Promise<T>
export type SitemapEntry = SitemapItemLoose | string

export type SitemapRoot = CreateFilterOptions & Omit<Partial<SitemapItemLoose>, 'url'>

export interface ModuleOptions extends CreateFilterOptions, SitemapStreamOptions {
  /**
   * Whether the sitemap.xml should be generated.
   *
   * @default true
   */
  enabled: boolean

  /**
   * Should the URLs be inserted with a trailing slash.
   *
   * @default false
   */
  trailingSlash: boolean

  inferStaticPagesAsRoutes: boolean
  /**
   * Default options to pass for each sitemap entry.
   */
  defaults: Omit<Partial<SitemapItemLoose>, 'url'>
  /**
   * Defaults URLS to be included in the sitemap.
   */
  urls: MaybeFunction<MaybePromise<SitemapEntry[]>>

  sitemaps: Record<string, SitemapRoot>
}

export interface ModuleHooks {
  'sitemap:generate': (ctx: { urls: SitemapItemLoose[]; sitemap: SitemapStream }) => Promise<void> | void
}

export default defineNuxtModule<ModuleOptions>({
  meta: {
    name: 'nuxt-simple-sitemap',
    compatibility: {
      nuxt: '^3.0.0',
      bridge: false,
    },
    configKey: 'sitemap',
  },
  defaults(nuxt) {
    const trailingSlash = process.env.NUXT_PUBLIC_TRAILING_SLASH || nuxt.options.runtimeConfig.public.trailingSlash
    return {
      include: ['/**'],
      exclude: [],
      hostname: process.env.NUXT_PUBLIC_SITE_URL || nuxt.options.runtimeConfig.public?.siteUrl,
      // false by default
      trailingSlash: (typeof trailingSlash !== 'undefined' ? trailingSlash : false) as boolean,
      enabled: true,
      urls: [],
      defaults: {},
      devPreview: true,
      inferStaticPagesAsRoutes: true,
    }
  },
  async setup(config, nuxt) {
    const { resolve } = createResolver(import.meta.url)

    // paths.d.ts
    addTemplate({
      filename: 'nuxt-simple-sitemap.d.ts',
      getContents: () => {
        return `// Generated by nuxt-simple-sitemap
import type { SitemapItemLoose } from 'sitemap'

type SitemapEntry = SitemapItemLoose & {
  changefreq?: 'always' | 'hourly' | 'daily' | 'weekly' | 'monthly' | 'yearly' | 'never' | (string & Record<never, never>)
}

interface NuxtSimpleSitemapNitroRules {
  index?: boolean
  sitemap?: SitemapEntry
}
declare module 'nitropack' {
  interface NitroRouteRules extends NuxtSimpleSitemapNitroRules {}
  interface NitroRouteConfig extends NuxtSimpleSitemapNitroRules {}
}
export {}
`
      },
    })

    nuxt.hooks.hook('prepare:types', ({ references }) => {
      references.push({ path: resolve(nuxt.options.buildDir, 'nuxt-simple-sitemap.d.ts') })
    })

    const pagesDirs = nuxt.options._layers.map(
      layer => resolve(layer.config.srcDir, layer.config.dir?.pages || 'pages'),
    )
    let urls: SitemapEntry[] = []
    if (typeof config.urls === 'function')
      urls = [...await config.urls()]

    else if (Array.isArray(config.urls))
      urls = [...await config.urls]

    const exposeConfig = {
      ...config,
      urls,
      pagesDirs,
      extensions: nuxt.options.extensions,
    }
    exposeModuleConfig('nuxt-simple-sitemap', exposeConfig)

    // always add the styles
    addServerHandler({
      route: '/_sitemap/style.xml',
      handler: resolve('./runtime/routes/sitemap.xsl'),
    })

    // multi sitemap support
    if (config.sitemaps) {
      addServerHandler({
        route: '/sitemap_index.xml',
        handler: resolve('./runtime/routes/sitemap_index.xml'),
      })
      addServerHandler({
        handler: resolve('./runtime/middleware/[sitemap]-sitemap.xml'),
      })
    }
    else {
      addServerHandler({
        route: '/sitemap.xml',
        handler: resolve('./runtime/routes/sitemap.xml'),
      })
    }

    // check if the user provided route /api/_sitemap-urls exists
    console.log(nuxt.options)

    nuxt.hooks.hook('nitro:init', async (nitro) => {
      // tell the user if the sitemap isn't being generated
      const logger = useLogger('nuxt-simple-sitemap')
      if (!config.hostname) {
        logger.warn('Please set a `hostname` on the `sitemap` config to use `nuxt-simple-sitemap`.')
        return
      }
      if (!config.enabled) {
        logger.warn('Sitemap generation is disabled. Set `sitemap.enabled` to `true` to enable it.')
        return
      }

      let sitemapGenerate = false
      const outputSitemap = async () => {
        if (!nuxt.options._build && !nuxt.options._generate)
          return

        if (sitemapGenerate)
          return
        const prerenderRoutes = nitro._prerenderedRoutes?.filter(r => !r.route.includes('.'))
          .map(r => ({ url: r.route })) || []
        const configUrls = [...prerenderRoutes, ...urls]

        let start = Date.now()

        const _routeRulesMatcher = toRouteMatcher(
          createRadixRouter({ routes: nitro.options.routeRules }),
        )

        const routeMatcher = (path: string) => defu({}, ..._routeRulesMatcher.matchAll(withoutBase(withoutTrailingSlash(path), nuxt.options.app.baseURL)).reverse())

        if (config.sitemaps) {
          start = Date.now()
          // rendering a sitemap_index
          const sitemapIndex = await buildSitemapIndex({ ...exposeConfig, urls: configUrls }, nuxt.options.app.baseURL, routeMatcher)
          await writeFile(resolve(nitro.options.output.publicDir, 'sitemap_index.xml'), sitemapIndex)
          const generateTimeMS = Date.now() - start
          nitro.logger.log(chalk.gray(
            `  └─ /sitemap_index.xml (${generateTimeMS}ms)`,
          ))
          // now generate all sub sitemaps
          for (const sitemap of Object.keys(config.sitemaps)) {
            const urls = await generateRoutes({ ...exposeConfig, ...config.sitemaps[sitemap], urls: configUrls }, nuxt.options.app.baseURL, routeMatcher)
            const stream = new SitemapStream({ ...config, xslUrl: `${config.hostname}sitemap.xsl` })
            const sitemapContext = { stream, urls }
            // Return a promise that resolves with your XML string
            const sitemapXml = await streamToPromise(Readable.from(sitemapContext.urls).pipe(sitemapContext.stream))
              .then(data => data.toString())
            await writeFile(resolve(nitro.options.output.publicDir, `${sitemap}-sitemap.xml`), sitemapXml)
            const generateTimeMS = Date.now() - start
            nitro.logger.log(chalk.gray(
              `  └─ /\`${sitemap}-sitemap.xml (${generateTimeMS}ms)`,
            ))
          }
        }
        else {
          const routes = await generateRoutes(exposeConfig, nuxt.options.app.baseURL, routeMatcher)
          const stream = new SitemapStream(config)
          const sitemapContext = { stream, urls: routes }
          // @ts-expect-error untyped
          await nuxt.hooks.callHook('sitemap:generate', sitemapContext)
          if (sitemapContext.urls.length === 0)
            return
          // Return a promise that resolves with your XML string
          const sitemapXml = await streamToPromise(Readable.from(sitemapContext.urls).pipe(sitemapContext.stream))
            .then(data => data.toString())
          await writeFile(resolve(nitro.options.output.publicDir, 'sitemap.xml'), sitemapXml)
          const generateTimeMS = Date.now() - start
          nitro.logger.log(chalk.gray(
            `  └─ /sitemap.xml (${generateTimeMS}ms)`,
          ))
        }
        sitemapGenerate = true
      }

      // SSR mode
      nitro.hooks.hook('rollup:before', async () => {
        await outputSitemap()
      })

      // SSG mode
      nitro.hooks.hook('close', async () => {
        await outputSitemap()
      })
    })
  },
})
